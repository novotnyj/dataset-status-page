<html>
    <head>
        <title>Status page</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.min.js"></script>
        <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.min.js"></script>
        <style>
            .list-group-item {
                padding: 0.5rem 1rem;
                cursor: pointer;
            }
            .crossed-text, .crossed-text:hover {
                text-decoration: line-through;
            }
        </style>
    </head>
    <body>
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
            <a class="navbar-brand" href="#">Status page</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="true" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <div class="navbar-nav" id="intervalsNavBar">
                </div>
            </div>
        </nav>

        <div class="container pt-4">
            <div class="container">
                <div class="row">
                    <div class="col-12">
                        <h4>Count of dataset items in time</h4>
                    </div>
                    <div class="col-12 no-data-alert">
                        <div class="alert alert-secondary">No data yet...</div>
                    </div>
                    <canvas id="items-in-time"></canvas>
                </div>

            </div>

            <div class="container pt-4">
                <div class="row">
                    <div class="col-12">
                        <h4>Item counts <small class="items-total"></small></h4>
                    </div>
                    <div class="col-12 no-data-alert">
                        <div class="alert alert-secondary">No data yet...</div>
                    </div>
                    <div class="col-8">
                        <canvas id="items-donut" width="100%"></canvas>
                    </div>
                    <div class="col-4">
                        <ul class="items-legend list-group list-group-flush pt-2"></ul>
                    </div>
                </div>
            </div>
        </div>
    <script type="application/javascript">
        window._statusPage = window._statusPage || {};

        const hash = location.hash.split('&').reduce(function (result, item) {
            const [name, value] = item.split('=');
            result[name.replace('#', '')] = value;
            return result;
        }, {});

        window._statusPage.interval = hash.interval || null;

        function setActiveClass(interval) {
            const active = document.querySelector('a[data-interval].active');
            active.classList.remove('active');
            const newActive = document.querySelector(`a[data-interval="${interval}"]`);
            newActive.classList.add('active');
        }

        function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function intervalChanged(e) {
            const overlay = document.querySelector('.overlay');
            const interval = e.srcElement.getAttribute('data-interval');
            window._statusPage.interval = interval;
            const promises = [];
            const start = Date.now();
            promises.push(window._statusPage.updateData());

            Promise.all(promises).then(() => {
                console.log('Reloaded');
                const elapsed = Date.now() - start;
            });

            setActiveClass(interval);
        }

        async function fetchColors() {
            const response = await fetch('/actor-colors.json');
            let data = await response.json();
            return data;
        }

        window.getActorColor = (actorName) => {
            if (!window._statusPage.actorColors) {
                fetchColors().then((colors) => {
                    window._statusPage.actorColors = colors;
                });
            }
            if (window._statusPage.actorColors[actorName]) {
                return window._statusPage.actorColors[actorName];
            }

            return '#34495e';
        }

        let runsCtx = document.querySelector('#items-in-time');

        const runDataToDataset = (values) => {
            let labels = [];
            values.forEach((item) => {
                labels.push(Date.parse(item.createdAt));
            });

            let actorNames = [...new Set(values.map((item) => item.actorName))];

            datasets = {};
            for (const actorName of actorNames) {
                const actorValues = values.filter((item) => item.actorName === actorName);
                datasets[actorName] = {
                    data: actorValues.map((item => ({ x: Date.parse(item.createdAt), y: item.cleanItemCount }))),
                    label: actorName.charAt(0).toUpperCase() + actorName.slice(1),
                    fill: false,
                    borderColor: window.getActorColor(actorName),
                    spanGaps: true,
                }
            }

            return {
                labels,
                datasets: Object.values(datasets),
            }
        };

        let chart;

        const createOrUpdateLines = (datasetData) => {
            let data = runDataToDataset(datasetData);
            const interval = window._statusPage.interval;
            console.log(data);

            if (chart) {
                chart.data = data;
                chart.options.scales.xAxes[0].time.tooltipFormat = interval === 'day' ? 'MM.DD. HH:mm' : 'MM.DD.';
                chart.options.scales.xAxes[0].scaleLabel.labelString = interval === 'day' ? 'Time' : 'Date';
                chart.options.scales.xAxes[0].time.unit = interval === 'day' ? false : 'day';
                chart.update(0);
                return;
            }

            chart = new Chart(runsCtx, {
                type: 'line',
                data,
                options: {
                    tooltips: {
                        callbacks: {
                            label: function(tooltipItem, data) {
                                let label = data.datasets[tooltipItem.datasetIndex].label || '';
                                if (label) {
                                    label += ': ';
                                }

                                label += tooltipItem.yLabel.toLocaleString();
                                return label;
                            }
                        }
                    },
                    scales: {
                        xAxes: [{
                            type: 'time',
                            time: {
                                tooltipFormat: interval === 'day' ? 'MM.DD. HH:mm' : 'MM.DD.',
                                unit: interval === 'day' ? false : 'day',
                            },
                            scaleLabel: {
                                display: true,
                                labelString: interval === 'day' ? 'Time' : 'Date',
                            }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: 'Item count'
                            },
                            ticks: {
                                callback: function(label, index, labels) {
                                    return label.toLocaleString();
                                }
                            },
                        }],
				    },
                }
            });
        };

        const charts = {
            cleanItemCount: {
                ctx: document.querySelector('#items-donut'),
                legendCtx: document.querySelector('.items-legend'),
                total: document.querySelector('.items-total'),
            },
        };

        const updateOrCreateChart = (data, chartName) => {
            const actorNames = [];
            data.forEach((item) => {
                if (!actorNames.includes(item.actorName)) {
                    actorNames.push(item.actorName);
                }
            });
            const colors = actorNames.map((name) => window.getActorColor(name));

            const chartData = actorNames.map((name) => {
                const values = data.filter((item) => item.actorName === name)
                    .reduce((prev, curr) => {
                        return prev + curr.cleanItemCount;
                    }, 0);
                return values;
            });

            let total = 0;
            data.forEach((item) => total += item[chartName]);

            charts[chartName].total.innerText = `(${total} total)`;

            const setLegend = (chart) => {
                const container = charts[chartName].legendCtx;
                container.innerHTML = chart.generateLegend();

                let items = Array.from(container.querySelectorAll('li'));
                items.forEach((item) => {
                    item.addEventListener('click', legendClickCallback, false);
                });
            };

            legendClickCallback = (event) => {
                event = event || window.event;

                let target = event.target || event.srcElement;
                while (target.nodeName !== 'LI') {
                    target = target.parentElement;
                }

                let parent = target.parentElement;
                let chart = charts[chartName].chart;
                let index = parseInt(target.getAttribute('data-index'), 10);
                let meta = chart.getDatasetMeta(0);
                //console.log(index);
                let item = meta.data[index];

                if (item.hidden === null || item.hidden === false) {
                    item.hidden = true;
                    target.classList.add('crossed-text');
                } else {
                    target.classList.remove('crossed-text');
                    item.hidden = null;
                }
                chart.update();
            }

            if (charts[chartName].chart) {
                /// Update chart
                charts[chartName].chart.data = {
                    datasets: [{
                        data: chartData,
                        backgroundColor: colors,
                    }],
                    labels: actorNames.map((name) => name.charAt(0).toUpperCase() + name.slice(1)),
                };
                charts[chartName].chart.update(0);
                setLegend(charts[chartName].chart);
                return;
            }

            const chart = new Chart(charts[chartName].ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: chartData,
                        backgroundColor: colors,
                    }],
                    labels: actorNames.map((name) => name.charAt(0).toUpperCase() + name.slice(1)),
                },
                options: {
                    tooltips: {
                        callbacks: {
                            label: function(tooltipItem, data) {
                                console.log(tooltipItem);
                                let label = data.labels[tooltipItem.datasetIndex] || '';
                                if (label) {
                                    label += ': ';
                                }

                                label += data.datasets[0].data[tooltipItem.datasetIndex].toLocaleString();
                                return label;
                            }
                        }
                    },
                    legend: false,
                    legendCallback: function(chart) {
                        let text = [];
                        let ds = chart.data.datasets[0];
                        let data = [];
                        for (var i=0; i < ds.data.length; i++) {
                            data.push({
                                name: chart.data.labels[i],
                                value: ds.data[i],
                                index: i,
                            });
                        }
                        function compare(a,b) {
                            if (a.name < b.name)
                                return -1;
                            if (a.name > b.name)
                                return 1;
                            return 0;
                        }
                        data = data.sort(compare);
                        for (const item of data) {
                            text.push(`<li class="list-group-item d-flex justify-content-between align-items-center" data-index="${item.index}">`);
                            text.push(`${item.name} <span class="badge badge-default badge-pill">${item.value.toLocaleString()}</span>`);
                            text.push('</li>');
                        }
                        return text.join("");
                    }
                }
            });
            charts[chartName].chart = chart;
            setLegend(chart);
        };

        async function loadIntervals() {
            const response = await fetch('/intervals.json');
            const data = await response.json();
            const intervals = data.intervals.map((item) => item.value);

            if (window._statusPage.interval && !intervals.includes(window._statusPage.interval)) {
                window._statusPage.interval = data.default;
            }

            const container = document.querySelector('#intervalsNavBar');
            const selectedInterval = window._statusPage.interval;
            function getItem(interval) {
                const el = document.createElement('a');
                el.setAttribute('class', interval.value === selectedInterval ? 'nav-item nav-link active' : 'nav-item nav-link');
                el.setAttribute('href', `#interval=${interval.value}`);
                el.setAttribute('data-interval', interval.value);
                el.innerHTML = interval.label;
                return el;
            }
            data.intervals.forEach((interval) => {
                const el = getItem(interval);
                container.appendChild(el);
            });

            const links = Array.from(document.querySelectorAll('a[data-interval]'));

            links.forEach((el) => {
                el.addEventListener('click', intervalChanged);
            });
        }

        const updateData = async () => {
            window._statusPage.actorColors = await fetchColors();

            const url = `/dataset-info.json?interval=${window._statusPage.interval}`;
            const response = await fetch(url);

            const data = await response.json();
            const alerts = Array.from(document.querySelectorAll('.no-data-alert'));
            if (data.length === 0) {
                alerts.forEach((el) => el.style.display = 'block');
            } else {
                alerts.forEach((el) => el.style.display = 'none');
            }

            createOrUpdateLines(data);
            for (const chartName of Object.keys(charts)) {
                updateOrCreateChart(data, chartName);
            }
        };

        window._statusPage.updateData = updateData;

        setInterval(updateData, 5 * 60 * 1000);

        function loadData() {
            updateData().then(() => {
                console.log('Data loaded');
            });
        }

        loadIntervals()
            .then(() => {
                loadData();
            });
    </script>
    </body>
</html>
